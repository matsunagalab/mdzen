"""State Definitions for Setup Phase (Phase 2).

This module defines state objects for the ReAct-based Setup Agent.
"""

import operator
from typing import Annotated, Sequence, TypedDict

from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages


def merge_outputs(left: dict, right: dict) -> dict:
    """Merge outputs dictionaries, preserving all keys.

    This reducer ensures outputs from multiple tool calls accumulate
    rather than overwrite each other. Right side takes precedence
    for duplicate keys (newer values win).

    Args:
        left: Existing outputs dictionary
        right: New outputs to merge

    Returns:
        Merged dictionary with all keys from both inputs
    """
    if left is None:
        return right or {}
    if right is None:
        return left or {}
    return {**left, **right}


class SetupAgentState(TypedDict):
    """State for the Setup Agent ReAct loop.

    This state is used by the setup agent to track:
    - Input from clarification phase (simulation_brief)
    - Session directory for all outputs (session_dir)
    - Tool-calling conversation (setup_messages)
    - Execution progress (completed_steps, current_step_index)
    - Results and logs (decision_log, outputs, raw_notes)
    - Final summary (compressed_setup)
    """

    # Input from Phase 1 (Clarification)
    simulation_brief: dict

    # Session directory - all MCP tools should use output_dir=session_dir
    # This ensures all workflow outputs are organized under one directory
    session_dir: str

    # ReAct loop state - messages accumulate via add_messages reducer
    setup_messages: Annotated[Sequence[BaseMessage], add_messages]

    # Execution tracking - completed_steps accumulate via operator.add
    completed_steps: Annotated[list[str], operator.add]  # e.g., ["prepare_complex", "solvate"]
    current_step_index: int

    # Decision logging for reproducibility - entries accumulate via operator.add
    decision_log: Annotated[list[dict], operator.add]
    # Each entry format:
    # {
    #   "tool": "structure_server__prepare_complex",
    #   "parameters": {...},
    #   "result": {...},  # Compressed result
    #   "duration_seconds": 45.3,
    #   "timestamp": "2025-01-15T10:30:00"
    # }

    # Outputs (file paths accumulate between steps via merge_outputs reducer)
    outputs: Annotated[dict, merge_outputs]  # {"merged_pdb": "path", "solvated_pdb": "path", ...}

    # Raw notes for debugging - accumulate via operator.add
    raw_notes: Annotated[list[str], operator.add]

    # Final summary generated by compress_setup node
    compressed_setup: str


class SetupOutputState(TypedDict):
    """Output state from setup phase to full agent.

    This defines what gets passed to Phase 3 (Validation).
    """

    session_dir: str  # Root directory for all outputs
    outputs: dict
    decision_log: list[dict]
    compressed_setup: str
    raw_notes: list[str]


# Fixed workflow steps (4 steps - matches MCP server architecture)
SETUP_STEPS = [
    "prepare_complex",  # structure_server: fetch + clean + parameterize + merge
    "solvate",  # solvation_server: water box or membrane embedding
    "build_topology",  # amber_server: generate prmtop + rst7 files
    "run_simulation",  # md_simulation_server: MD execution + analysis
]
